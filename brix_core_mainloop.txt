--@name BRIX: Main Coroutine
--@shared

function BRIX:onUpdate(frame)

    self.frame = math.ceil(frame)
    self.level = self:getLevelFromFrame(frame)
    self:updateGameStage()

end


function BRIX:checkBackToBack(lines, tspin, noupdate)

    if tspin or lines == 4 then
        if not noupdate then self.backToBack = true end
        --self.backToBack = true
        return true
    else
        if not noupdate then self.backToBack = false end
        --self.backToBack = false
        return false
    end

end


function BRIX:checkCombo(cleared)

    if not cleared then self.currentCombo = nil return end
    if not self.currentCombo then
        self.currentCombo = 0
    else
        self.currentCombo = self.currentCombo + 1
    end

end

function BRIX:checkAttempts(attempts, lowest, rotating)

    local p = self.currentPiece
    local newLow = self:_lowestPoint(p.piece, p.rot, p.x, p.y)
    if newLow < lowest then
        lowest = newLow
        attempts = 0
        self:startTimer("lock", brix.lockDelay)
    elseif attempts < brix.lockResets then
        attempts = attempts + 1
        self:startTimer("lock", brix.lockDelay)
    elseif p.spin and not rotating then
        p.spin = false
    end
    return attempts, lowest

end

function BRIX:co_main()

    local cevents = brix.CLIENT_EVENTS
    while true do
    
        local attempts = 0
        local lowest = brix.trueHeight
        local instantLock = false
    ::startOver::
        
        --generation
            --random bag
            --spawn piece in position
        self.heldThisPhase = false
        self:newPiece()
        
        ::beginTimer::
        local p = self.currentPiece
        if not self:_fits(p.piece, p.rot, p.x, p.y) then
            print("BLOCK OUT")
            break
        end -- block out
        if not self:fitsDown() then goto locking end
        
        --self:startTimer("drop", self:getFramesPerDrop())
        self:startTimer("drop", 0) -- drops immediately
        if self.inputs[cevents.MOVELEFT] then
            self:startTimer("moveleft", brix.autoRepeatSpeed)
            self:cancelTimer("moveright")
        elseif self.inputs[cevents.MOVERIGHT] then
            self:startTimer("moveright", brix.autoRepeatSpeed)
            self:cancelTimer("moveleft")
        end
        
        attempts = 0
        lowest = brix.trueHeight
        instantLock = false
        
    ::falling::
        while self:fitsDown() do
            
            local event, what = self:pullEvent()
            if event == "timer" and what == "drop" then
                self:moveDown()
                if not self:fitsDown() then -- touched ground
					self.hook:run("pieceLand")
                    break
                end
                self:startTimer("drop", self:getFramesPerDrop())
                
            elseif event == "timer" and what == "lock" then
                instantLock = true
                
            elseif event == "timer" and what == "moveleft" then
                self:moveLeft()
                self:startTimer("moveleft", brix.autoRepeatSpeed)
                --if not self:fitsDown() then break end
                
            elseif event == "timer" and what == "moveright" then
                self:moveRight()
                self:startTimer("moveright", brix.autoRepeatSpeed)
                --if not self:fitsDown() then break end
                
            elseif event == "inputDown" or event == "inputUp" then
            
                local down = event == "inputDown"
                if down then
                    if what == cevents.MOVELEFT then
                        self:moveLeft()
                        self:startTimer("moveleft", brix.autoRepeatBegin)
                        self:cancelTimer("moveright")
                        --if not self:fitsDown() then break end
                        
                    elseif what == cevents.MOVERIGHT then
                        self:moveRight()
                        self:startTimer("moveright", brix.autoRepeatBegin)
                        self:cancelTimer("moveleft")
                        --if not self:fitsDown() then break end
                    
                    elseif what == cevents.SOFTDROP then
                        self:moveDown()
                        self:startTimer("drop", self:getFramesPerDrop())
                        
                    elseif what == cevents.HARDDROP then
                        self:hardDrop()
                        self:cancelTimer("drop")
                        goto lock
                        
                    elseif what == cevents.HOLD and self:hold() then
                        goto beginTimer
                    
                    elseif what == cevents.ROT_CW then
                        self:rotateClockwise()
                        
                    elseif what == cevents.ROT_CCW then
                        self:rotateAntiClockwise()
                       
                    -- handle targeting events outside coroutine 
                    end
                        
                else -- button released
                
                    if what == cevents.MOVELEFT then
                        self:cancelTimer("moveleft")
                    
                    elseif what == cevents.MOVERIGHT then
                        self:cancelTimer("moveright")
                    
                    elseif what == cevents.SOFTDROP then
                        -- todo: start timer in reference to the last frame the piece fell?
                        self:startTimer("drop", self:getFramesPerDrop())
                    
                    end
                
                end
                
            end
            
            local p = self.currentPiece
            local newLow = self:_lowestPoint(p.piece, p.rot, p.x, p.y)
            if newLow < lowest then
                lowest = newLow
                attempts = 0
            end
                
        end
        
    ::locking::
        -- We have made contact with a surface
        
        if attempts < brix.lockResets then
            self:startTimer("lock", brix.lockDelay)
        elseif instantLock then
            goto lock
        end
        
        --lock
        while true do
        
            local event, what = self:pullEvent()
            if event == "timer" then
            
                if what == "lock" then 
                    --if not self:fitsDown() then
                        break
                    --else
                    --    print("would have locked")
                    --end
                elseif what == "drop" and self:fitsDown() then
                    self:startTimer("drop", 0)
                    goto falling -- this will drop the piece and reset the counter
                    
                elseif what == "moveleft" then
                    self:startTimer("moveleft", brix.autoRepeatSpeed)
                    if self:moveLeft() then
                        attempts, lowest = self:checkAttempts(attempts, lowest)
                        if self:fitsDown() then
                            self:startTimer("drop", self:getFramesPerDrop())
                            goto falling
                        end
                    end
                    
                elseif what == "moveright" then
                    self:startTimer("moveright", brix.autoRepeatSpeed)
                    if self:moveRight() then
                        attempts, lowest = self:checkAttempts(attempts, lowest)
                        if self:fitsDown() then
                            self:startTimer("drop", self:getFramesPerDrop())
                            goto falling
                        end
                    end
                end
            
            elseif event == "inputDown" then
                
                if what == cevents.MOVELEFT then
                    self:startTimer("moveleft", brix.autoRepeatBegin)
                    self:cancelTimer("moveright")
                    if self:moveLeft() then
                        attempts, lowest = self:checkAttempts(attempts, lowest)
                        if self:fitsDown() then
                            self:startTimer("drop", self:getFramesPerDrop())
                            goto falling
                        end
                    end
                
                elseif what == cevents.MOVERIGHT then
                    self:startTimer("moveright", brix.autoRepeatBegin)
                    self:cancelTimer("moveleft")
                    if self:moveRight() then
                        attempts, lowest = self:checkAttempts(attempts, lowest)
                        if self:fitsDown() then
                            self:startTimer("drop", self:getFramesPerDrop())
                            goto falling
                        end
                    end
                
                elseif what == cevents.HARDDROP then
                    break
                    
                elseif what == cevents.HOLD and self:hold() then
                    goto beginTimer
                    
                elseif what == cevents.ROT_CW and self:rotateClockwise() then
                    attempts, lowest = self:checkAttempts(attempts, lowest, true)
                    if self:fitsDown() then
                        self:startTimer("drop", self:getFramesPerDrop())
                        goto falling
                    end
                    
                elseif what == cevents.ROT_CCW and self:rotateAntiClockwise() then
                    attempts, lowest = self:checkAttempts(attempts, lowest, true)
                    if self:fitsDown() then
                        self:startTimer("drop", self:getFramesPerDrop())
                        goto falling
                    end
                    
                end
                
            elseif event == "inputUp" then
            
                if what == cevents.MOVELEFT then
                    self:cancelTimer("moveleft")
                elseif what == cevents.MOVERIGHT then
                    self:cancelTimer("moveright")
                end 
            
            end
        
        end
        
    ::lock::
        local lockedVisibly, tspin = self:lock()
        if not lockedVisibly then
            print("LOCK OUT")
            break
        end
        
        
        
    ::lineClears::
        
        local lines = {}
        for i = 0, brix.trueHeight - 1 do
        
            if #self.matrix:getrow(i):gsub(" ","") == brix.w then
                table.insert(lines, i)
            end
        
        end
        
        -- do stuff if no lines (ie dump garbage)
        self:checkCombo(#lines > 0)
        
        if #lines > 0 then
            for _, line in pairs(lines) do
                
                self.matrix:setrow(line, string.rep(" ", brix.w))
                
            end
            
            local linesSent, tricks = self:calcLinesSent(#lines, tspin)
            linesSent = self:clearGarbage(linesSent)
            self.hook:run("postlock", tricks, self.currentCombo, linesSent, lines)
            
            self:checkBackToBack(#lines, tspin)

			if self.CLIENT then
            	self:sleep("lineClear", brix.clearDelay)
			end
            
        
            local cleared = 0
            for _, line in pairs(lines) do
            
                for i = line, brix.trueHeight - 1 do
                
                    i = i - cleared
                    local fill = (" "):rep(brix.w)
                    if i + 1 < brix.trueHeight then
                        fill = self.matrix:getrow(i + 1)
                    end
                    self.matrix:setrow(i, fill)
                
                end
                cleared = cleared + 1
            
            end
            
            if cleared > 0 then
                self.hook:run("matrixFall")
            end

			if self.SERVER then
				self:sleep("lineClear", brix.clearDelay)
			end
        
        else
        
            local tricks = 0
            if tspin == 2 then
                tricks = enumSet(tricks, brix.tricks.TSPIN)
            elseif tspin == 1 then
                tricks = enumSet(tricks, brix.tricks.MINI_TSPIN)
            end
            self.hook:run("postlock", tricks, 0, 0, {})
        
            if self:garbageDumpPending() then
                self:sleep("dumpDelay", brix.garbageDumpDelay)
                self:dumpCurrentGarbage()
            end
        
        end
        
        self:updateDanger()
        
        self:sleep("spawnDelay", brix.pieceAppearDelay)
        
        self.hook:run("phaseComplete")
        
        --detect line clears
        --animate 
        --eliminate phase (collapsing) OR garbage dump
        
        --do break end
        
    end

	self.diedAt = self.frame
	self.hook:run("die")

end
